"use strict";(self.webpackChunkguide_pycord_dev=self.webpackChunkguide_pycord_dev||[]).push([[1453],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),c=r,h=u["".concat(d,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6555:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Tasks"},d=void 0,l={unversionedId:"extensions/tasks/tasks",id:"extensions/tasks/tasks",title:"Tasks",description:"Concept",source:"@site/docs/extensions/tasks/tasks.mdx",sourceDirName:"extensions/tasks",slug:"/extensions/tasks/",permalink:"/extensions/tasks/",draft:!1,editUrl:"https://github.com/Pycord-Development/guide/tree/main/docs/extensions/tasks/tasks.mdx",tags:[],version:"current",lastUpdatedBy:"Lala Sabathil",lastUpdatedAt:1713441056,formattedLastUpdatedAt:"Apr 18, 2024",frontMatter:{title:"Tasks"},sidebar:"defaultSidebar",previous:{title:"Paginator FAQ",permalink:"/extensions/pages/paginator-faq"},next:{title:"Voice",permalink:"/voice/"}},p={},u=[{value:"Concept",id:"concept",level:2},{value:"Example Usage",id:"example-usage",level:3},{value:"Tasks",id:"tasks",level:2},{value:"Creating a task",id:"creating-a-task",level:3},{value:"Attributes",id:"attributes",level:3},{value:"Example",id:"example",level:3}],m={toc:u},c="wrapper";function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"concept"},"Concept"),(0,o.kt)("p",null,"So you want to run a background task running at some specified interval? Thankfully, that's a common thing to do, whether you're working with some API or handling some background logic don't worry, the Pycord tasks extension is here to make life easier for you!"),(0,o.kt)("p",null,'With the tasks extension, you can make background tasks without worrying about the asyncio hell and mind bogglers like "what if my internet dies" and "how do I handle reconnecting" with the added benefit of a lot of useful additions that are one line of code away!'),(0,o.kt)("h3",{id:"example-usage"},"Example Usage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"import discord\nfrom discord.ext import tasks\n\nbot = discord.Bot()\n\n@bot.event\nasync def on_ready():\n    very_useful_task.start()\n\n@tasks.loop(seconds=5)\nasync def very_useful_task():\n    print('doing very useful stuff.')\n\nbot.run(\"TOKEN\")\n")),(0,o.kt)("p",null,"If you do run this code in your terminal you should see something like this after about 15 seconds:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"doing very useful stuff.\ndoing very useful stuff.\ndoing very useful stuff.\n")),(0,o.kt)("p",null,"For a more useful example here's a task in a cog context ripped straight from the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.pycord.dev/en/stable/ext/tasks/index.html#recepies"},"docs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"from discord.ext import tasks, commands\n\nclass MyCog(commands.Cog):\n    def __init__(self):\n        self.index = 0\n        self.printer.start()\n\n    def cog_unload(self):\n        self.printer.cancel()\n\n    @tasks.loop(seconds=5)\n    async def printer(self):\n        print(self.index)\n        self.index += 1\n")),(0,o.kt)("p",null,"As you'd expect this will increment a number and print it out every 5 seconds like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"0\n# 5 seconds later\n1\n# 5 more seconds later\n2\n# ...\n")),(0,o.kt)("h2",{id:"tasks"},(0,o.kt)("a",{parentName:"h2",href:"https://docs.pycord.dev/en/stable/ext/tasks/index.html"},"Tasks")),(0,o.kt)("p",null,"Now let's get into the nitty-gritty of tasks."),(0,o.kt)("p",null,"As you've seen tasks can work in both outer scope and class contexts and the handle is roughly the same, you define a task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"tasks.loop")," decorator and use the ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," method to start it, the difference is you add the ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," argument when in a class context so since most people have all their bot's code in Cogs all the following code blocks will be in a Cog context to make it easy to copy it then apply whatever modifications you might need!"),(0,o.kt)("h3",{id:"creating-a-task"},(0,o.kt)("a",{parentName:"h3",href:"https://docs.pycord.dev/en/stable/ext/tasks/index.html#discord.ext.tasks.loop"},"Creating a task")),(0,o.kt)("p",null,"A look at ",(0,o.kt)("inlineCode",{parentName:"p"},"discord.ext.tasks.loop"),"'s definition in the documentation reveals that:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"As you've seen before it expects the time between each execution, that however doesn't have to be in seconds as\nthere are ",(0,o.kt)("inlineCode",{parentName:"li"},"seconds"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"minutes")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"hours")," parameters to make it easier for us, they can also be floats in case you want\nultra-precision."),(0,o.kt)("li",{parentName:"ol"},"You can also pass in a ",(0,o.kt)("inlineCode",{parentName:"li"},"datetime.time")," object or a sequence of them in the ",(0,o.kt)("inlineCode",{parentName:"li"},"time")," parameter which will make it run\nat the specified time(s)."),(0,o.kt)("li",{parentName:"ol"},"You can pass in how many times a loop runs before it stops by passing in the ",(0,o.kt)("inlineCode",{parentName:"li"},"count")," parameter, you can use ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"\nto make it run forever which is also the default."),(0,o.kt)("li",{parentName:"ol"},"The loop function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"must"))," be a coroutine.")),(0,o.kt)("p",null,"These are all really useful, and they aren't the only parameters so if you want to know more about them check out the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.pycord.dev/en/stable/ext/tasks/index.html#discord.ext.tasks.loop"},"docs"),"!"),(0,o.kt)("h3",{id:"attributes"},"Attributes"),(0,o.kt)("p",null,"A task has the following attributes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"current_loop"),": The current loop the task is on."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"hours"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"minutes"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"seconds"),": attributes that represent the time between each execution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"time"),": A list of datetime.time objects that represent the times the task will run, returns ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," if no datetime\nobjects were passed."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"next_iteration"),": A ",(0,o.kt)("inlineCode",{parentName:"li"},"datetime.datetime")," object that represents the next time the next iteration of the task will\nrun, can return ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," if the task stopped running.")),(0,o.kt)("p",null,"These attributes serve as a really powerful asset to get info about your loop."),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,"Now let's create a cog that handles a leaderboard we have in our bot using Tasks then explain what we did after that and\nalso provide a refresher of how slash commands groups work in cogs."),(0,o.kt)("p",null,"For the sake of this example let's pretend that we have a leaderboard module that does all the leaderboard handling for\nus and that computing the leaderboard is very expensive computationally wise, so we want to store one version of it that\ngets regularly updated instead of generating it every time someone calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"/leaderboard view")," command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'from discord.ext import tasks, commands\nfrom discord.commands import SlashCommandGroup, CommandPermissions\n\nfrom leaderboard import * # Mock leaderboard module.\n\nclass LeaderboardCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.update_leaderboard.start()\n        self.leaderboard_embed = generate_leaderboard_embed()\n\n    leaderboard = SlashCommandGroup(name=\'leaderboard\', description=\'Leaderboard commands.\')\n\n    @tasks.loop(minutes=10)\n    async def update_leaderboard(self):\n        print(\'Updating leaderboard...\')\n        await update_leaderboard()\n        self.leaderboard_embed = generate_leaderboard_embed()\n\n    @update_leaderboard.before_loop\n    async def before_update_leaderboard(self):\n        await self.bot.wait_until_ready()\n        print("About to start updating leaderboard.")\n\n    @update_leaderboard.after_loop\n    async def after_update_leaderboard(self):\n        leaderboard_cleanup()\n        print("Stopped updating leaderboard.")\n\n    @update_leaderboard.error\n    async def update_leaderboard_error(self, error):\n        print(f"Oh no, an error occurred while updating the leaderboard. Error: {error}")\n\n    @leaderboard.command()\n    async def view(self, ctx):\n        await ctx.respond(embed=self.leaderboard_embed)\n\n    @leaderboard.command()\n    async def update_info(self, ctx):\n        await ctx.respond(f"""***Leaderboard Info***\\n\n                              Last update: {(600 - self.update_leaderboard.next_iteration.timestamp())//60} minutes ago.\\n\n                              Next update: in {self.update_leaderboard.next_iteration.timestamp() // 60} minutes.\\n\n                              Time between loops: {self.update_leaderboard.minutes} minutes.\\n\n                              Times updated this session: {self.update_leaderboard.current_loop}.\n                              Running? {self.update_leaderboard.is_running()}\n                              Failed? {self.update_leaderboard.failed()}""", ephemeral=True)\n\n    # Now for the owner only commands:\n\n    leaderboard_config = SlashCommandGroup(name="leaderboard_config", description="Leaderboard configuration commands", permission=[CommandPermissions("owner", 2, True)])\n\n    @leaderboard_config.command()\n    async def set_time_between_updates(self, ctx, minutes: int):\n        self.update_leaderboard.change_interval(minutes=minutes)\n        await ctx.respond(f"Set time between updates to {minutes} minutes.")\n\n    @leaderboard_config.command()\n    async def stop(self, ctx):\n        self.update_leaderboard.stop()\n        await ctx.respond("Stopped the leaderboard update.")\n\n    @leaderboard_config.command()\n    async def restart(self, ctx):\n        self.update_leaderboard.restart()\n        await ctx.respond("Restarted the leaderboard update.")\n\ndef setup(bot):\n    bot.add_cog(LeaderboardCog(bot))\n')),(0,o.kt)("p",null,"Phew, that was quite a bit of code."),(0,o.kt)("p",null,"Now to explain what's going on:"),(0,o.kt)("p",null,"First things first we create a cog and in its ",(0,o.kt)("inlineCode",{parentName:"p"},"__init__")," function we start the ",(0,o.kt)("inlineCode",{parentName:"p"},"update_leaderboard")," task and generate\nthe first instance of our leaderboard's embed."),(0,o.kt)("p",null,"After that, we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"update_leaderboard")," task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," decorator, and we make it run every ten minutes by\npassing 10 to the ",(0,o.kt)("inlineCode",{parentName:"p"},"minutes")," parameter."),(0,o.kt)("p",null,"Then that we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"before_update_leaderboard")," task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"before_loop")," decorator, and we make it wait until the\nbot is ready before starting the task."),(0,o.kt)("p",null,"Next up we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"after_update_leaderboard")," task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"after_loop")," decorator, and we make it clean up the\nleaderboard when the loop finally stops running."),(0,o.kt)("p",null,"Then we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"update_leaderboard_error")," task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"error")," decorator, and we make it print any errors that may\noccur while we update our leaderboard to the console."),(0,o.kt)("p",null,"Then we get into the fun stuff, we create a slash command group using the ",(0,o.kt)("inlineCode",{parentName:"p"},"SlashCommandGroup")," class and name it\n",(0,o.kt)("inlineCode",{parentName:"p"},"leaderboard"),", we then create the ",(0,o.kt)("inlineCode",{parentName:"p"},"view")," sub-command which sends the embed generated when the leaderboard is updated and\n",(0,o.kt)("inlineCode",{parentName:"p"},"update_info")," which shows a lot of data about the task using some attributes and functions available to us."),(0,o.kt)("p",null,"We also create a slash command group called ",(0,o.kt)("inlineCode",{parentName:"p"},"leaderboard_config")," which is only available to the owner of the bot."),(0,o.kt)("p",null,"Then we create the ",(0,o.kt)("inlineCode",{parentName:"p"},"set_time_between_updates")," sub-command which takes in the time in minutes and changes the time\nbetween updates of the leaderboard using the ",(0,o.kt)("inlineCode",{parentName:"p"},"change_interval")," method, the ",(0,o.kt)("inlineCode",{parentName:"p"},"stop")," sub-command which stops the task using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"stop")," method and ",(0,o.kt)("inlineCode",{parentName:"p"},"restart")," which restarts the task using the ",(0,o.kt)("inlineCode",{parentName:"p"},"restart")," method."),(0,o.kt)("p",null,"Finally, we add the ",(0,o.kt)("inlineCode",{parentName:"p"},"LeaderboardCog")," cog to the bot, and we're done!"),(0,o.kt)("p",null,"I'd highly recommend you check the tasks extension\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.pycord.dev/en/stable/ext/tasks/index.html"},"documentation")," for more info on how to use them and what other\nfunctions they have."))}h.isMDXComponent=!0}}]);